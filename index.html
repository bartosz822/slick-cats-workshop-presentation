<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/solarized.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/atom-one-dark.css">
		<link rel="stylesheet" href="css/custom.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>

		<img src="imgs/vl-logo.png" alt="Virtus Lab"
     style="background: none; border: none; box-shadow: none; position: absolute; bottom:10%; right: 10%; z-index: 1;"/>

		<div class="reveal">
			<div class="slides">
				<section data-markdown>
						## Slick Cats Workshop


						#### Szymon Tracz Bartosz Radzy≈Ñski
				</section>
				<section data-background-image="imgs/slick-logo-background.png" data-background-size="180px 180px" data-background-repeat="repeat" data-background-color="white">
					<section data-markdown>
						# Slick
					

						##### Functional-relational mapping
					</section>
					<section>
						Slick is a modern database query and access library for Scala. It allows you to work with stored data almost as if you were using Scala collections while at the same time giving you full control over when a database access happens and which data is transferred. You can write your database queries in Scala instead of SQL, thus profiting from the static checking, compile-time safety and compositionality of Scala. Slick features an extensible query compiler which can generate code for different backends.
					</section>
					<section data-markdown class="center">
						### Case Class definition
						```scala
						case class Cat(
							id: Option[Long],
  							name: String,
  							breedId: Long,
  							sex: String,
  							age: Int
						)
						```
					</section>
					<section data-markdown>
						### Table definition
						```scala
						class Cats(tag: Tag) extends IdTable[Cat](tag, "cats") {

						  def id = column[Long]("id", O.PrimaryKey, O.AutoInc)
						  def name = column[String]("name")
						  def breedId = column[Long]("breed_id")
						  def sex = column[String]("sex")
						  def age = column[Int]("age")

						  def breedFk = foreignKey("breed_fk", breedId, Breeds.query)(_.id)

						  def *  =  (id.?, name, breedId, sex, age) <> (Cat.tupled, Cat.unapply)
						}

						object Cats {
						  lazy val query = TableQuery[Cats]
						}
						```
					</section>
					<section data-markdown>
						### Adding to table
						```scala
						Cats.query ++ Cat(id = None, name = "Bella", breedId = 2, sex = "F", age = 3)
						```
						### Accesing table
						```scala
						Cats.query.forEach(println)

						Cats.filer(_.age < 5)

						Cats.map(_.name).forEach(println)
						```
					</section>
					<section data-markdown>
						### Running an action

						```scala
						import slick.jdbc.H2Profile.api._
						import scala.concurrent.ExecutionContext.Implicits.global

						```

						```scala
						catsDb = {
							url = "jdbc:h2:mem:cats"
  							driver = org.h2.Driver
  							connectionPool = disabled
  							keepAliveConnection = true
						}
						```
						
						```scala
						val db = Database.forConfig("catsDb")
						
						val action = Cats.query.forEach(println)

						val futureResult = db.run(action)
						```
					</section>
				</section>


				<!--SLICK + CATS - why?-->

				<section>
					<section>
						<h2>Slick + cats</h2>
						<img data-src="imgs/slick-cats-puzzle.png" style="width: 30%; height: 30%; background: none; border: none; box-shadow: none;">
					</section>
				</section>

				<!--CATS-->


				<section class="cats" data-background-image="imgs/cats-logo-background.png" data-background-size="249px 244px" data-background-repeat="repeat" data-background-color="#292E53">
					<section data-markdown>
						# Cats
					</section>
					<section data-background-image="imgs/cats-hierarchy.svg" data-background-position="right 60%">
						<aside class="notes">
							That's only to scare you a bit
						</aside>
					</section>
					<section data-markdown>
						# Typeclass
					</section>
					<section data-markdown>
						### The problem
						```scala
						case class Cat(name: String, breedName: String)

						def present = ??? //this one needs to be generic

						val skipper = Cat("Skipper", "Maine Coon")
						present(skipper)
						// = "This is Skipper, Maine Coon"
						```
					</section>
					<section data-markdown>
						### OOP
						```scala
						trait Showable {
							def show: String
						}
						case class Cat(name: String, breedName: String) extends Showable {
							def show: String = name + ", " + breedName
						}

						def present(showable: Showable) = "This is " + showable.show

						val skipper = Cat("Skipper", "Maine Coon")
						present(skipper)
						// = "This is Skipper, Maine Coon"
						```
					</section>
					<section data-markdown>
						### Typeclass
						```scala
						case class Cat(name: String, breedName: String)

						trait Show[A] {
							def show(a: A): String
						}

						implicit val showCat = new Show[Cat] {
							def show(cat: Cat): String = cat.name + ", " + cat.breedName
						}

						def present[A](a: A)(implicit s: Show[A]) = "This is " + s.show(a)

						val skipper = Cat("Skipper", "Maine Coon")
						present(skipper)
						// = "This is Skipper, Maine Coon"
						```
					</section>
					<section data-markdown>
						<script type="text/template">
						###### Ad hoc polymorphism
						```scala
						implicit val showCat = new Show[Cat] {
						//we make cat showable by telling how to show it and not by changing the cat itself
							def show(cat: Cat): String = cat.name + ", " + cat.breedName
						}
						def present[A](a: A)(implicit s: Show[A]) = "This is " + s.show(a)
						```

						###### Implicit argument as a constraint <!-- .element: class="fragment" data-fragment-index="1" -->
						```scala
						def present[ThingType](thing: ThingType)(implicit s: Show[ThingType])
						//This signature says "We can present a thing if Show instance for ThingType is provided"
						```
						<!-- .element: class="fragment" data-fragment-index="1" -->

						###### Logic about data structures is part of their instances <!-- .element: class="fragment" data-fragment-index="2" -->
						```scala
						case class Cat(name: String, breedName: String)
						//cat is just a data structure, no logic inside

						implicit val showCat = new Show[Cat] { //Show instance for cat
							def show(cat: Cat): String = cat.name + ", " + cat.breedName //logic is here
						}
						```
						<!-- .element: class="fragment" data-fragment-index="2" -->
						</script>
					</section>
					<section data-markdown>
						### Typeclass resolution in Scala
					</section>
					<section data-markdown>
						### Postfix operators
					</section>
					<section data-markdown>
						### Monad
					</section>
					<section data-markdown>
						### Option T
					</section>
					<section data-markdown>
						### Either T
					</section>
					<section data-markdown>
						### Useful things
					</section>
					<section data-markdown>
						### Semigroup
					</section>
					<section data-markdown>
						### Validated vs. Either
					</section>
				</section>


				<!--Drawbacks-->


				<section>
					<section data-markdown>
						# Drawbacks
					</section>
					<section data-markdown>
						### Failing type inference
						DbioAction, FlatMapAction, etc.
					</section>
					<section data-markdown>
						Are there any more drawbacks?
					</section>
				</section>


				<!--Extras-->


				<section>
					<section data-markdown>
						# Extras
					</section>
					<section data-markdown>
						### Unicorn
						```scala
						/** Id class for type-safe joins and queries. */
						case class UserId(id: Long) extends AnyVal with BaseId[Long]

						case class UserRow(
							id: Option[UserId],
							email: String,
							name: String
						) extends WithId[Long, UserId]

						/** Table definition for users. */
						class Users(tag: Tag) extends IdTable[UserId, UserRow](tag, "USERS") {
							def email = column[String]("EMAIL")
							def name = column[String]("LAST_NAME")
							override def * = (id.?, email, name) <> (UserRow.tupled, UserRow.unapply)
						}
						```
						https://github.com/VirtusLab/unicorn
					</section>
					<section data-background-iframe="https://www.scala-exercises.org/cats" data-background-interactive>
						<h2>Cats exercises</h2>
					</section>
				</section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			Reveal.initialize({
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				],
				width: '90%',
				height: '90%',
				progress: true,
				mouseWheel: false,
				history: true,
				transition: 'convex',
				transitionSpeed: 'fast',
				// parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'

			});
		</script>
	</body>
</html>
